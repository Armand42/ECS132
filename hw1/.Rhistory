2/6
2/6 + 3/6 + 4/6 + 5/6
clear
cler()
llll
2/6
(1/6)*4
(1/6)^4
(1/6)^3
pik(3,2)
return(
pik(i+1, k-1) +
pik(i+2, k-1) +
pik(i+3, k-1) +
pik(i+4, k-1) +
pik(i+5, k-1) +
pik(i+6, k-1)
)
pik(3,2)
source('~/notes/s19/132/hw1/hw1.R')
pik(3,2)
source('~/notes/s19/132/hw1/hw1.R')
pik(3,2)
source('~/notes/s19/132/hw1/hw1.R')
pik(3,2)
pik(7,1)
pik(7,2)
pik(3,2)
pik(5,3)
source('~/notes/s19/132/hw1/hw1.R')
pik(7,1)
pik(3,2)
source('~/notes/s19/132/hw1/hw1.R')
pik(3,2)
pik(7,1)
pik(7,2)
pik(3,2)
source('~/notes/s19/132/hw1/hw1.R')
source('~/notes/s19/132/hw1/hw1.R')
pik(7,1)
pik(7,2)
pik(3,2)
runif(1)
runif(1)
runif(1)
runif(1)
for (j in 1:2) {
cat("yay")
}
source('~/notes/s19/ECS132/hw1/hw1.R')
sim(0.4, 0.8, 1000)
pik <- function(i, k) {
# if land/pass 0th square and not on the kth turn, do not count this series of rolls
if (i > 7 && k != 0) {
return(0)
}
# else if land/pass 0th square, and on kth turn, then success
else if (i > 7 & k == 0) {
return(1)
}
# else if out of turns and havent passed square 7 at all, return 0
else if (k == 0) {
return(0)
}
# recursive function, counting each possible roll of the die, subtracting 1 from each turn
else {
return(
((1/6) * pik(i+1, k-1)) +
((1/6) * pik(i+2, k-1)) +
((1/6) * pik(i+3, k-1)) +
((1/6) * pik(i+4, k-1)) +
((1/6) * pik(i+5, k-1)) +
((1/6) * pik(i+6, k-1))
)
}
}
source('~/notes/s19/ECS132/hw1/Code.R')
sim(0.40, 0.80, 100000)
p <- 0.4
q <- 0.8
2p(1-p)
2*p
2*p*(1-p)
2*p*(1-p) * ((p*(1-q)) + (1-p)*(1-q) + p*(1-p)*q)
2*p*(1-p) * ((1-p)*(1-q) + p*(1-p)*q + (1-p)*p*q)
2p*(1-p)
2*p*(1-p) + p*(1-q) + 2*p*(1-p)*q
0.944 / 0.24192
0.944 / 0.504
source('~/notes/s19/ECS132/hw1/Code.R')
sim(0.4, 0.8, 100000)
2*p*(1-p) * [(1-p)*(1-q) + q*2*p*(1-p)]
2*p*(1-p) * ((1-p)*(1-q) + q*2*p*(1-p))
source('~/notes/s19/ECS132/hw1/Code.R')
sim(0.4, 0.8, 100000)
2*p*(1-p) * 2*p*(1-p)
0.24192 + 0.2304
0.47232 / 0.24192
2*(1-p)*(1-p) * 2(1-p)*(1-p)
2*(1-p)*(1-p) * 2*(1-p)*(1-p)
(1-p)*(1-p) * (1-p)*(1-p)
0.24192 + 0.1296
